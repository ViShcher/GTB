name: Telegram Full Repo Dump

on:
  push:
    branches:
      - "**"

jobs:
  dump:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare file list (tracked only)
        id: files
        run: |
          # Список файлов под git (исключает то, что в .gitignore)
          git ls-files -z > tracked.txt

          # Фильтр по расширениям: только текстовые/конфиг/скрипты
          # Добавляй свои расширения при необходимости
          cat tracked.txt | tr '\0' '\n' | \
          grep -E '\.(py|pyi|txt|md|rst|toml|ini|cfg|conf|json|yml|yaml|toml|xml|csv|tsv|env\.example|sql|sh|bash|Dockerfile|procfile|gitignore|editorconfig)$|(^Dockerfile$)|(^Procfile$)|(^\.env\.example$)|(^Makefile$)' \
          > text_files.txt || true

          # Дополнительно исключим потенциально чувствительное
          # (вдруг кто-то назвал файл странно)
          grep -v -i -E '(^|/)\.env($|\.|/)|(^|/)secrets?($|/)|(^|/)token|(^|/)credentials?' text_files.txt > text_files_sanitized.txt || true

          echo "count=$(wc -l < text_files_sanitized.txt | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Build repo_dump.txt
        run: |
          OUT="repo_dump.txt"
          : > "$OUT"
          echo "# Repository dump for $GITHUB_REPOSITORY" >> "$OUT"
          echo "# Commit: $GITHUB_SHA" >> "$OUT"
          echo "# Branch: $GITHUB_REF_NAME" >> "$OUT"
          echo "# Pushed by: $GITHUB_ACTOR" >> "$OUT"
          echo "# Date (UTC): $(date -u '+%Y-%m-%d %H:%M:%S')" >> "$OUT"
          echo "" >> "$OUT"

          while IFS= read -r file; do
            # Пропустим слишком большие одиночные файлы (>1.5MB) на всякий
            if [ -f "$file" ] && [ $(stat -c%s "$file") -le 1572864 ]; then
              echo "========================================" >> "$OUT"
              echo "FILE: $file" >> "$OUT"
              echo "----------------------------------------" >> "$OUT"
              # Попытка прочитать как текст; если бинарь — пропустим
              if file -bi "$file" | grep -qi 'charset='; then
                cat "$file" >> "$OUT"
              else
                echo "[skipped non-text or unknown encoding]" >> "$OUT"
              fi
              echo "" >> "$OUT"
            else
              echo "========================================" >> "$OUT"
              echo "FILE: $file" >> "$OUT"
              echo "----------------------------------------" >> "$OUT"
              echo "[skipped due to size >1.5MB or missing file]" >> "$OUT"
              echo "" >> "$OUT"
            fi
          done < text_files_sanitized.txt

          # Печать итогового размера
          du -h "$OUT"

      - name: Send to Telegram (split if large)
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          MAX_CHUNK=$((45 * 1024 * 1024))  # ~45MB на кусок для запаса
          SIZE=$(stat -c%s repo_dump.txt)

          SUMMARY="📦 Full repo dump
Repo: $GITHUB_REPOSITORY
Branch: $GITHUB_REF_NAME
Commit: $GITHUB_SHA
Files: ${{ steps.files.outputs.count }}
Size: $(du -h repo_dump.txt | cut -f1)
Pusher: $GITHUB_ACTOR"

          # Отправим краткое сообщение
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT_ID}" \
            --data-urlencode "text=${SUMMARY}" > /dev/null

          if [ "$SIZE" -le "$MAX_CHUNK" ]; then
            # Отправляем одним документом
            curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument" \
              -F chat_id="${TG_CHAT_ID}" \
              -F document="@repo_dump.txt" \
              -F caption="repo_dump.txt (весь проект одним файлом)" > /dev/null
          else
            # Режем и шлём частями
            split -b $MAX_CHUNK -d -a 2 repo_dump.txt repo_dump_part_
            for f in repo_dump_part_*; do
              curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument" \
                -F chat_id="${TG_CHAT_ID}" \
                -F document="@$f" \
                -F caption="$f" > /dev/null
            done
          fi
